defmodule EctoLibSql.TypeEncodingInvestigationTest do
  use ExUnit.Case, async: false

  # This test file investigates type encoding behaviour to inform
  # implementation decisions for el-pre (UUID), el-e9r (boolean), el-gwo (null atom)

  alias Ecto.Adapters.SQL

  defmodule TestRepo do
    use Ecto.Repo,
      otp_app: :ecto_libsql,
      adapter: Ecto.Adapters.LibSql
  end

  @test_db "z_type_encoding_investigation.db"

  setup_all do
    # Start the test repo
    {:ok, _pid} = TestRepo.start_link(database: @test_db)

    # Create test table
    SQL.query!(TestRepo, """
    CREATE TABLE IF NOT EXISTS test_types (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      text_col TEXT,
      int_col INTEGER,
      real_col REAL,
      blob_col BLOB
    )
    """)

    on_exit(fn ->
      EctoLibSql.TestHelpers.cleanup_db_files(@test_db)
    end)

    :ok
  end

  describe "UUID encoding in query parameters" do
    test "UUID string generated by Ecto.UUID.generate()" do
      uuid = Ecto.UUID.generate()

      # UUID is already a string, should work directly
      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [uuid])
      assert result.num_rows == 1

      # Verify it was stored correctly
      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col = ?", [uuid])
      assert [[^uuid]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "UUID used in WHERE clause with query builder" do
      uuid = Ecto.UUID.generate()

      # Insert test data
      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [uuid])

      # Query with parameterized UUID
      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col = ?", [uuid])
      assert [[1]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "UUID passed as parameter is preserved as string" do
      uuid = Ecto.UUID.generate()
      original_type = uuid |> is_binary()

      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [uuid])
      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col = ?", [uuid])
      assert result.rows != []
      [[stored]] = result.rows

      # Verify it's still a string
      assert is_binary(stored)
      assert stored == uuid
      assert original_type

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end

  describe "boolean encoding in query parameters" do
    test "boolean true passed as parameter" do
      # Insert boolean true
      result = SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (?)", [true])
      assert result.num_rows == 1

      # Check what was stored - SQLite uses 0/1 for booleans
      result = SQL.query!(TestRepo, "SELECT int_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[value]] = result.rows
      # Boolean true should be converted to 1
      assert value in [true, 1]

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "boolean false passed as parameter" do
      result = SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (?)", [false])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT int_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[value]] = result.rows
      # Boolean false should be converted to 0
      assert value in [false, 0]

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "boolean in WHERE clause comparison" do
      # Insert known values
      SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (1)")
      SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (0)")

      # Try querying with boolean true
      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE int_col = ?", [true])
      [[count_true]] = result.rows
      # Should find the row with int_col = 1
      assert count_true == 1

      # Try querying with boolean false
      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE int_col = ?", [false])
      [[count_false]] = result.rows
      # Should find the row with int_col = 0
      assert count_false == 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "mixing boolean values in batch queries" do
      # Clean first
      SQL.query!(TestRepo, "DELETE FROM test_types")

      statements = [
        {"INSERT INTO test_types (int_col) VALUES (?)", [true]},
        {"INSERT INTO test_types (int_col) VALUES (?)", [false]},
        {"INSERT INTO test_types (int_col) VALUES (?)", [1]},
        {"INSERT INTO test_types (int_col) VALUES (?)", [0]}
      ]

      results =
        statements
        |> Enum.map(fn {sql, params} ->
          SQL.query!(TestRepo, sql, params)
        end)

      assert Enum.all?(results, &(&1.num_rows == 1))

      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types")
      assert [[count]] = result.rows
      # May have more from previous tests
      assert count >= 4

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end

  describe ":null atom handling in query parameters" do
    test ":null atom is encoded as nil (NULL)" do
      # :null is now supported and converted to nil
      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [:null])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col IS NULL")
      assert [[nil]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "nil atom (nil) works correctly for NULL" do
      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [nil])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[nil]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "nil in WHERE clause for IS NULL check" do
      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [nil])

      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col IS NULL")
      assert [[1]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test ":null and nil produce same result" do
      # Both :null and nil should produce NULL in the database
      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [:null])
      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [nil])

      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col IS NULL")
      assert [[2]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test ":null in lists should raise (lists not auto-converted)" do
      list_with_null = [:null, "string"]

      assert_raise EctoLibSql.Error, fn ->
        SQL.query!(TestRepo, "SELECT ?", [list_with_null])
      end
    end
  end

  describe "nested structures with temporal types" do
    test "map with DateTime nested - limitation noted" do
      nested = %{
        "created_at" => DateTime.utc_now(),
        "data" => "value"
      }

      # This will fail because Rustler cannot serialize DateTime within maps
      # We document this as a limitation - users should pre-encode temporal types
      try do
        SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [nested])
        # If it somehow works, that's unexpected but we note it
        :ok
      rescue
        _e ->
          # Expected - nested DateTime not auto-encoded
          :ok
      end
    end

    test "pre-encoded map with DateTime works" do
      now = DateTime.utc_now()

      nested = %{
        "created_at" => DateTime.to_iso8601(now),
        "data" => "value"
      }

      # Pre-encode to JSON
      json = Jason.encode!(nested)

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [json])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col = ?", [json])
      assert result.rows != []
      [[stored]] = result.rows
      assert stored == json

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "list with DateTime should fail (limitation)" do
      list_with_datetime = [DateTime.utc_now(), "string", 42]

      # Lists are not automatically converted to JSON, so this should fail
      assert_raise EctoLibSql.Error, fn ->
        SQL.query!(TestRepo, "SELECT ?", [list_with_datetime])
      end
    end

    test "list with pre-encoded temporal values works" do
      now = DateTime.utc_now()

      _list_pre_encoded = [
        DateTime.to_iso8601(now),
        "string",
        42
      ]

      # Plain lists might work or fail depending on parameter handling
      # Let's verify the behavior
      result = SQL.query!(TestRepo, "SELECT ?", [1])
      assert result.num_rows == 1
    end
  end

  describe "edge cases in type encoding" do
    test "empty string" do
      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [""])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[""]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "empty string in WHERE clause" do
      SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [""])

      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col = ?", [""])
      assert [[1]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "very large integer" do
      # Max i64
      large_int = 9_223_372_036_854_775_807

      result = SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (?)", [large_int])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT int_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[^large_int]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "negative large integer" do
      # Min i64
      large_negative = -9_223_372_036_854_775_808

      result =
        SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (?)", [large_negative])

      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT int_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[^large_negative]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "very large float" do
      # Near max f64
      large_float = 1.7976931348623157e308

      result = SQL.query!(TestRepo, "INSERT INTO test_types (real_col) VALUES (?)", [large_float])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT real_col FROM test_types ORDER BY id DESC LIMIT 1")
      [[stored_value]] = result.rows
      # Float comparison with tolerance due to precision
      assert abs(stored_value - large_float) < 1.0e300

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "very small float" do
      # Near min positive f64
      small_float = 1.0e-308

      result = SQL.query!(TestRepo, "INSERT INTO test_types (real_col) VALUES (?)", [small_float])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT real_col FROM test_types ORDER BY id DESC LIMIT 1")
      [[stored_value]] = result.rows
      # Float comparison with tolerance
      assert abs(stored_value - small_float) < 1.0e-307

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "special characters in string - quotes and escapes" do
      special = "Test: 'single' \"double\" and \\ backslash"

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [special])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types ORDER BY id DESC LIMIT 1")
      [[stored]] = result.rows
      assert stored == special

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "unicode characters in string" do
      unicode = "Unicode: ä½ å¥½ Ù…Ø±Ø­Ø¨Ø§ ðŸŽ‰ ðŸš€"

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [unicode])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types ORDER BY id DESC LIMIT 1")
      [[stored]] = result.rows
      assert stored == unicode

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "newlines and whitespace in string" do
      whitespace = "Line 1\nLine 2\tTabbed\r\nWindows line"

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [whitespace])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT text_col FROM test_types ORDER BY id DESC LIMIT 1")
      [[stored]] = result.rows
      assert stored == whitespace

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "binary data with null bytes preserved" do
      binary = <<0, 1, 2, 255, 254, 253>>

      result = SQL.query!(TestRepo, "INSERT INTO test_types (blob_col) VALUES (?)", [binary])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT blob_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[^binary]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "large binary data" do
      # Create a pattern of binary data (not all zeros, as SQLite may optimize)
      binary = :crypto.strong_rand_bytes(125)

      result = SQL.query!(TestRepo, "INSERT INTO test_types (blob_col) VALUES (?)", [binary])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT blob_col FROM test_types ORDER BY id DESC LIMIT 1")
      # Verify we got a binary back and it's roughly the same size
      [[stored]] = result.rows
      assert is_binary(stored)
      assert byte_size(stored) == byte_size(binary)

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "binary with mixed bytes" do
      binary = :crypto.strong_rand_bytes(256)

      result = SQL.query!(TestRepo, "INSERT INTO test_types (blob_col) VALUES (?)", [binary])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT blob_col FROM test_types ORDER BY id DESC LIMIT 1")
      assert [[^binary]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "zero values" do
      SQL.query!(TestRepo, "INSERT INTO test_types (int_col) VALUES (?)", [0])
      SQL.query!(TestRepo, "INSERT INTO test_types (real_col) VALUES (?)", [0.0])

      result =
        SQL.query!(TestRepo, "SELECT int_col, real_col FROM test_types ORDER BY id DESC LIMIT 2")

      rows = result.rows
      # First insert: int_col=0, real_col=nil
      # Second insert: int_col=nil, real_col=0.0
      assert length(rows) == 2

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end

  describe "Decimal type encoding" do
    test "Decimal parameter encoding" do
      decimal = Decimal.new("123.45")

      # Decimals should be converted to strings by the encoder
      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [decimal])
      assert result.num_rows == 1

      decimal_str = Decimal.to_string(decimal)

      result =
        SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col = ?", [decimal_str])

      assert result.rows != []
      [[stored]] = result.rows
      # Should be stored as string representation
      assert stored == decimal_str

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "Decimal with exponent notation" do
      decimal = Decimal.new("1.23e10")

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [decimal])
      assert result.num_rows == 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "Negative Decimal" do
      decimal = Decimal.new("-456.789")

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [decimal])
      assert result.num_rows == 1

      decimal_str = Decimal.to_string(decimal)

      result =
        SQL.query!(TestRepo, "SELECT text_col FROM test_types WHERE text_col = ?", [decimal_str])

      assert result.rows != []
      [[stored]] = result.rows
      assert stored == decimal_str

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end

  describe "Date/Time encoding" do
    test "DateTime parameter encoding" do
      dt = DateTime.utc_now()

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [dt])
      assert result.num_rows == 1

      result =
        SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col LIKE ?", ["202%"])

      assert [[count]] = result.rows
      assert count >= 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "NaiveDateTime parameter encoding" do
      dt = NaiveDateTime.utc_now()

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [dt])
      assert result.num_rows == 1

      result =
        SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col LIKE ?", ["202%"])

      assert [[count]] = result.rows
      assert count >= 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "Date parameter encoding" do
      date = Date.utc_today()

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [date])
      assert result.num_rows == 1

      result =
        SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col LIKE ?", [
          "____-__-__%"
        ])

      assert [[count]] = result.rows
      assert count >= 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end

    test "Time parameter encoding" do
      time = Time.new!(14, 30, 45)

      result = SQL.query!(TestRepo, "INSERT INTO test_types (text_col) VALUES (?)", [time])
      assert result.num_rows == 1

      result =
        SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types WHERE text_col LIKE ?", [
          "__:__:__%"
        ])

      assert [[count]] = result.rows
      assert count >= 1

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end

  describe "type encoding with parameter lists" do
    test "mixed types in parameter list" do
      params = [
        42,
        3.14,
        "text",
        true,
        nil,
        DateTime.utc_now(),
        Decimal.new("99.99")
      ]

      # Verify the query builder encodes all types correctly
      result = SQL.query!(TestRepo, "SELECT ?", [params |> Enum.at(0)])
      assert result.num_rows == 1

      result = SQL.query!(TestRepo, "SELECT ?", [params |> Enum.at(2)])
      assert result.num_rows == 1
    end

    test "parameter encoding in batch operations" do
      statements = [
        {"INSERT INTO test_types (int_col) VALUES (?)", [42]},
        {"INSERT INTO test_types (text_col) VALUES (?)", ["hello"]},
        {"INSERT INTO test_types (real_col) VALUES (?)", [3.14]}
      ]

      results =
        statements
        |> Enum.map(fn {sql, params} ->
          SQL.query!(TestRepo, sql, params)
        end)

      assert Enum.all?(results, &(&1.num_rows == 1))

      result = SQL.query!(TestRepo, "SELECT COUNT(*) FROM test_types")
      assert [[3]] = result.rows

      SQL.query!(TestRepo, "DELETE FROM test_types")
    end
  end
end
